# -*- coding: utf-8 -*-
"""PS1_PartB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ztet7djfEcGyxoEsWOhyOCD-1V3ATZmC

## Loading the c-elegans dataset
"""

import base64
import requests

# We pull the c-elegans dataset f

def fetch_dataset(dataset, filename):
  """
  To fetch a dataset from the FCNS datasets page
  and save it locally
  https://github.com/CambridgeUniversityPress/FirstCourseNetworkScience/tree/master/datasets
  """
  
  datasets_page = "https://raw.githubusercontent.com/CambridgeUniversityPress/FirstCourseNetworkScience/master/datasets/"
  link = "{}/{}/{}".format(datasets_page, dataset, filename)
  
  req = requests.get(link).text
  with open(filename,"w") as f:
    f.write(req)

dataset = "celegansneural"
filename = "celegansneural.edges"
fetch_dataset(dataset, filename)

# Part B
# Group members 
# Joyneel Misra, Daniel Callow, Leslie Jordan, Rob Dalka, Khiem Lam, Riya Samanta

# Import Libraries
import networkx as nx
import numpy as np


# Read the adjacency list 
with open(filename, 'r') as f:
  G = nx.read_weighted_edgelist(f)
#

# Print and draw the graph for visualization purposes
print(nx.info(G))
nx.draw(G, pos=nx.spring_layout(G),
       with_labels=True,
       node_color='blue',
       node_size=100,
       font_color='white',
       font_size=5)
nx.get_edge_attributes(G,'weight')



"""## 1a. Histogram of the degree distribution

"""

# 1 (a) Plot degree distribution

# Get sequence of the degrees in graph G
### Degree is the number of nodes a node is connected to
degree_sequence =[G.degree(n) for n in G.nodes]

# Get statistics module and mean and median degrees
import statistics
print('Mean degree:', statistics.mean(degree_sequence))
print('Median degree:', statistics.median(degree_sequence))

# Import collections as Counter
from collections import Counter

# Save variable degree_counts for the count of each degree value in G
degree_counts = Counter(degree_sequence)
print(degree_counts)

# Set range (min  and max) degree for graph 
min_degree, max_degree = min(degree_counts.keys()), max(degree_counts.keys())
plot_x = list(range(min_degree, max_degree + 1))
plot_y = [degree_counts.get(x, 0) for x in plot_x]

# Import matplotlib
import matplotlib.pyplot as plt

# Plot and make density='True' to normalize the histogram
plt.hist(degree_sequence,bins=50,density='True')

plt.title("Degree Histogram")
plt.ylabel("P(k)")
plt.xlabel("Degree(k)")

"""The histogram shown above displays the probability of a randomly chosen node from the c-elegans network having a particular degree or number of edges. The histogram indicates that most nodes in this dataset have a degree somewhere in the range of 1 - 20.

## 1b. Histogram of the betweenness distribution of nodes.
"""

# 1 (b) Plot histogram of betweeness distibution of nodes

# Calculate betweeness and create a sequence of betweeness values
### Weight taken into consideration when the betweenness centrality is calculated.
### Betweenness is the fraction of shortest path lengths that pass through a node
betweenness = nx.centrality.betweenness_centrality(G, weight='weight') 

# Create a list of betweenness values
betweenness_sequence = list(betweenness.values())

# Print mean and median values as well as the list of values
print('Mean betweenness:', statistics.mean(betweenness_sequence))
print('Median betweenness:', statistics.median(betweenness_sequence))
print(betweenness_sequence)

# Plot betweenness values while accounting for density (normalise to 1)
plt.hist(betweenness.values(), bins=50, density=True)
betweenness_sequence
plt.title("Betweenness Histogram")
plt.ylabel("Count")
plt.xlabel("Betweenness")

"""The histogram shown above displays the frequency of nodes having each betweenness value, represented along the x-axis. Betweenness measures the number of shortest paths between pairs of other nodes that node *i* is on. Most nodes have betweenness values on the low end of the histogram, while a few nodes have high betweenness values.

## 1c. Scatter plot of node betweenness vs node degree
"""

# 1 (c) Make scatter plot of node betweenness vs node degree
plt.xlabel('Betweenness')
plt.ylabel('Degree')
plt.scatter(betweenness_sequence, degree_sequence, marker='o')

"""The scatter plot shown above displays the relationship between degree and betweenness across all nodes in the c-elegans network. This data visualization shows that higher degree tends to be associated with higher betweenness in the c-elegans dataset.

## 2a. Random Removal
"""

# Getting size of the largest component of the network
# Print connected components
print(nx.connected_components(G))

# Get first item in connected_components(G) and set it equal to variable core
core = next(nx.connected_components(G))
print(len(core))

# Checking the number of components in the network (only 1)
components = list(nx.connected_components(G))
len(components)

# Create new graph to attack
C = G.copy()

import random
#random selection of nodes to remove
nodes_to_remove = random.sample(list(C.nodes), 2)
# remove the nodes from copied graphs
C.remove_nodes_from(nodes_to_remove)

# Set M to the number of nodes divided by 25 
# Equals 11
number_of_steps = 25
M = G.number_of_nodes() // number_of_steps
M

# Create a sequence of nodes from 0 to number of nodes counting by 11's
num_nodes_removed = range(0, G.number_of_nodes(), M)

N = G.number_of_nodes()
C = G.copy()
random_attack_core_proportions = []
for nodes_removed in num_nodes_removed:
    # Measure the relative size of the network core
    core = next(nx.connected_components(C))
    # Get proportion of  nodes in core component
    core_proportion = len(core) / N

    # Create a list of core proportion values
    random_attack_core_proportions.append(core_proportion)
    
    # If there are more than M nodes, select M nodes at random and remove them
    if C.number_of_nodes() > M:
        nodes_to_remove = random.sample(list(C.nodes), M)
        C.remove_nodes_from(nodes_to_remove)

# Plot number of nodes removed agains the proportion of nodes in the core component
plt.title('Random failure')
plt.xlabel('Number of nodes removed')
plt.ylabel('Proportion of nodes in core')
plt.plot(num_nodes_removed, random_attack_core_proportions, marker='o')

"""## 2b. Targeted removal by degree"""

# Set M to the number of nodes divided by 25 
# Equals 11
N = G.number_of_nodes()
number_of_steps = 25
M = N // number_of_steps

# Create a sequence of nodes from 0 to number of nodes counting by 11's
num_nodes_removed = range(0, N, M)

# Create copy of new graph to attack
C = G.copy()

# Create an empty list to record proportion of nodes in core component after each attack
targeted_degree_attack_core_proportions = []

# Loop to remove top M (11) nodes by degree from network and caclulate proportion of nodes in core component
# Continues until there are less than M (11) nodes left
for nodes_removed in num_nodes_removed:
    # Measure the relative size of the network core
    core = next(nx.connected_components(C))
    core_proportion = len(core) / N
    # Calculate proportion of nodes in the core component and add to list
    targeted_degree_attack_core_proportions.append(core_proportion)
    
    # If there are more than M nodes, select top M nodes by degree and remove them
    if C.number_of_nodes() > M:
        # Sort nodes by degree
        nodes_sorted_by_degree = sorted(C.nodes, key=C.degree, reverse=True)
        # Select and remove top M nodes
        nodes_to_remove = nodes_sorted_by_degree[:M]
        C.remove_nodes_from(nodes_to_remove)

# Plot number of nodes removed against the proportion of nodes in the core component
plt.title('Targeted attack')
plt.xlabel('Number of nodes removed')
plt.ylabel('Proportion of nodes in core')
plt.plot(num_nodes_removed, targeted_degree_attack_core_proportions, marker='o')

"""## 2c. Targeted removal by betweenness

We remove nodes from the graph in $25$ steps.
We calculate the number of nodes removed in each step, $M$, by dividing the number of nodes in the graph, $N$, by the number of steps.
"""

N = G.number_of_nodes()
number_of_steps = 25
M = N // number_of_steps

"""Now, we will loop over the $25$ steps.
In each step we:
- measure and record the relative size of the network core.
- compute the betweenness centrality of all the notwork core nodes.
- arrange the nodes in decreasing order of their betweenness values.
- select top M nodes with highest betweenness values and remove them.
"""

num_nodes_removed = range(0, N, M)
C = G.copy()
targeted_betweenness_attack_core_proportions = []

# Loop over the number of steps
for nodes_removed in num_nodes_removed:

    # Measure and record the relative size of the network core
    core = next(nx.connected_components(C))
    core_proportion = len(core) / N
    targeted_betweenness_attack_core_proportions.append(core_proportion)
    
    # If there are more than M nodes, select top M nodes and remove them
    if C.number_of_nodes() > M:

        # Compute betweenness centrality of all nodes
        # weight considered for the shortest path calculation
        betweenness = nx.centrality.betweenness_centrality(C,weight='weight') 
        nodes = np.array([key for key in betweenness.keys()])
        betweenness_values = np.array([value for value in betweenness.values()])

        # Arrange nodes in decreasing order of betweenness values
        node_order = np.argsort(betweenness_values)
        node_order = np.flip(node_order)
        nodes_sorted_by_betweenness = list(betweenness_keys[node_order])#sorted(betweenness_keys, key=betweenness_values, reverse=True)
        
        # Select top M nodes with highest betweenness values and remove them
        top_betweenness_nodes = nodes_sorted_by_betweenness[:M]
        C.remove_nodes_from(top_betweenness_nodes)

"""Finally, we plot the relative size of the network core as a function of the network core."""

plt.title('Targeted attack')
plt.xlabel('Number of nodes removed')
plt.ylabel('Proportion of nodes in core')
plt.plot(num_nodes_removed, targeted_betweenness_attack_core_proportions, marker='o')

"""## Comparing 2a, 2b, 2c

On plotting the three different curves on the same figure, we see that the C-Elegans network is more vulnerable to targetted removal than random removal of nodes. The relative size of the network core is approaches to zero on removing close to half the total number of nodes both by degree and betweenness. However, the network is more vulnerable to a targetted attack by betweenness than by degree.
"""

plt.title('Random failure vs. targeted attack')
plt.xlabel('Number of nodes removed')
plt.ylabel('Proportion of nodes in core')
plt.plot(num_nodes_removed, random_attack_core_proportions, marker='o', label='Random')
plt.plot(num_nodes_removed, targeted_degree_attack_core_proportions, marker='^', label='Degree')
plt.plot(num_nodes_removed, targeted_betweenness_attack_core_proportions, marker='^', label='Betweenness')
plt.legend()

"""# Part 3
### Comments have been added throughout the code

# Part 4
### All group members shared their individual solutions to Part A through the group slack. We then all got together over Zoom to discuss each question and came to consensus on the solutions.

### For part B, Joyneel Misra wrote the code to bring in datasets from Github. Daniel Callow wrote the original code for problem 1. Then most of the group (Joyneel Misra, Daniel Callow, Rob Dalka, Leslie Jordan, and Khiem Lam) got together over Zoom to discuss problem 1 and then all worked together while Joyneel Misra typed out our code on google collab. While Riya Samanta could not make our original coding session, she went through the whole notebook, and made edits, specifically making corrections to the weighted betweeness centrality and normalized the histograms.

### Since we fetch the dataset directly from Github, the code runs on each of our own machines.
"""